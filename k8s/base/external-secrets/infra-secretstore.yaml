# ==============================================================================
# External Secrets Configuration for Infrastructure Services (Redis, RabbitMQ)
# ==============================================================================
#
# Context: ft_transcendence DevOps Module
# Component: External Secrets Operator Integration
#
# Purpose:
#   This manifest configures the External Secrets Operator (ESO) to synchronize
#   infrastructure service credentials (Redis, RabbitMQ) from HashiCorp Vault
#   to Kubernetes Secrets in the target namespace.
#
# Multi-Environment Support:
#   This file is a TEMPLATE designed to be applied to multiple namespaces.
#   The placeholder {{NAMESPACE}} must be replaced before applying.
#
#   Usage:
#     # For dev namespace
#     sed 's/{{NAMESPACE}}/dev/g' infra-secretstore.yaml | kubectl apply -f -
#
#     # For production namespace
#     sed 's/{{NAMESPACE}}/production/g' infra-secretstore.yaml | kubectl apply -f -
#
# Architecture:
#   1. ServiceAccount: infra-secrets-sa
#      - Used by ESO to authenticate with Vault via Kubernetes Auth Method
#      - Bound to 'infra-role' in Vault (see kubernetes-auth.sh)
#
#   2. SecretStore: vault-backend
#      - Namespaced store (one per target namespace)
#      - Configures connection to Vault with Kubernetes auth
#      - Uses 'infra-role' which grants access to shared secrets
#
# Vault Paths:
#   - secret/shared/redis     (Redis password)
#   - secret/shared/rabbitmq  (RabbitMQ password + Erlang cookie)
#
# Vault Policy: shared-policy (read access to secret/+/shared/*)
#
# See:
#   - https://external-secrets.io/latest/provider/hashicorp-vault/
#   - infrastructure/vault/policies/shared-policy.hcl
#   - infrastructure/vault/config/kubernetes-auth.sh
#
# ==============================================================================

---
# ==============================================================================
# 1. ServiceAccount for Infrastructure Secrets
# ==============================================================================
# This ServiceAccount is used by the External Secrets Operator's SecretStore
# to authenticate with Vault. The SA token is sent to Vault, which verifies it
# via the Kubernetes TokenReview API and returns a Vault token with the
# permissions defined in 'shared-policy'.
#
# Security Note:
#   - This SA only has permissions to read shared infrastructure secrets
#   - It cannot access service-specific secrets (e.g., auth JWT keys)
#   - The SA is namespace-scoped for isolation
#
# Vault Role Binding:
#   The 'infra-role' in Vault is configured to accept this ServiceAccount
#   from both 'dev' and 'production' namespaces:
#     bound_service_account_names=infra-secrets-sa
#     bound_service_account_namespaces=dev,production
# ==============================================================================
apiVersion: v1
kind: ServiceAccount
metadata:
  name: infra-secrets-sa
  namespace: "{{NAMESPACE}}"
  labels:
    app.kubernetes.io/name: infra-secrets
    app.kubernetes.io/component: external-secrets
    app.kubernetes.io/part-of: ft-transcendence
    app.kubernetes.io/managed-by: kubectl
  annotations:
    # Documentation annotation for audit and discoverability
    description: "ServiceAccount used by SecretStore to authenticate with Vault for Redis/RabbitMQ secrets"

---
# ==============================================================================
# 2. SecretStore for Vault Integration
# ==============================================================================
# A SecretStore is a namespaced resource that defines HOW to connect to an
# external secrets provider (in our case, HashiCorp Vault).
#
# Configuration:
#   - Provider: HashiCorp Vault
#   - Server: Internal Kubernetes service address (vault.vault.svc)
#   - Auth: Kubernetes authentication method
#   - Role: infra-role (maps to shared-policy in Vault)
#
# Why SecretStore vs ClusterSecretStore?
#   - SecretStore is namespace-scoped (more secure, follows least privilege)
#   - ClusterSecretStore would allow any namespace to use it (less secure)
#   - We use SecretStore to isolate each namespace's secret access
#   - Each namespace (dev, production) has its own SecretStore instance
#
# Connection Flow:
#   1. ExternalSecret references this SecretStore
#   2. ESO uses infra-secrets-sa token to authenticate with Vault
#   3. Vault verifies the token via Kubernetes TokenReview API
#   4. Vault returns a token with shared-policy permissions
#   5. ESO fetches secrets and creates Kubernetes Secrets
# ==============================================================================
apiVersion: external-secrets.io/v1
kind: SecretStore
metadata:
  name: vault-backend
  namespace: "{{NAMESPACE}}"
  labels:
    app.kubernetes.io/name: vault-backend
    app.kubernetes.io/component: external-secrets
    app.kubernetes.io/part-of: ft-transcendence
    app.kubernetes.io/managed-by: kubectl
spec:
  provider:
    vault:
      # -------------------------------------------------------------------------
      # Vault Server Configuration
      # -------------------------------------------------------------------------
      # Address of the Vault service within the Kubernetes cluster.
      # Using the full DNS name: <service>.<namespace>.svc.cluster.local
      #
      # Note: We use HTTP because TLS is terminated at the Ingress level.
      # Internal cluster traffic is considered trusted (private network).
      # For enhanced security, enable TLS on Vault and update this URL.
      server: "http://vault.vault.svc.cluster.local:8200"

      # -------------------------------------------------------------------------
      # KV Secrets Engine Configuration
      # -------------------------------------------------------------------------
      # Path to the KV secrets engine mount point in Vault.
      # This is NOT the full path to secrets, just the engine mount.
      #
      # Full secret paths are specified in ExternalSecret resources:
      #   secret/shared/redis     -> remoteRef.key: "secret/shared/redis"
      #   secret/shared/rabbitmq  -> remoteRef.key: "secret/shared/rabbitmq"
      path: "secret"

      # KV engine version. We use v2 for:
      #   - Secret versioning (rollback capability)
      #   - Metadata support (creation time, version info)
      #   - Check-and-set operations (CAS) for safe updates
      #   - Soft delete and undelete functionality
      version: "v2"

      # -------------------------------------------------------------------------
      # Authentication Configuration
      # -------------------------------------------------------------------------
      auth:
        kubernetes:
          # Mount path of the Kubernetes Auth Method in Vault.
          # This is configured by setup-vault.sh and kubernetes-auth.sh.
          # Default is "kubernetes" but can be customized for multi-cluster setups.
          mountPath: "kubernetes"

          # The Vault role to assume when authenticating.
          # This role is defined in kubernetes-auth.sh and grants access to
          # the 'shared-policy' which allows reading:
          #   - secret/shared/redis
          #   - secret/shared/rabbitmq
          #
          # The role accepts ServiceAccounts from multiple namespaces:
          #   bound_service_account_namespaces=dev,production
          role: "infra-role"

          # Reference to the ServiceAccount used for authentication.
          # ESO will use this SA's token to authenticate with Vault.
          # The SA must be in the same namespace as this SecretStore.
          serviceAccountRef:
            name: infra-secrets-sa
