# ==============================================================================
# External Secrets Configuration for Grafana (Monitoring Stack)
# ==============================================================================
#
# Context: ft_transcendence DevOps Module
# Component: kube-prometheus-stack / External Secrets Operator
#
# Purpose:
#   This manifest configures the External Secrets Operator (ESO) to synchronize
#   Grafana admin credentials from HashiCorp Vault to a Kubernetes Secret.
#   The Secret is then consumed by Grafana for initial admin authentication.
#
# Architecture:
#   1. ServiceAccount: monitoring-secrets-sa
#      - Used by ESO to authenticate with Vault via Kubernetes Auth Method
#      - Bound to 'monitoring-role' in Vault (see kubernetes-auth.sh)
#
#   2. SecretStore: vault-backend
#      - Namespaced store (monitoring namespace only)
#      - Configures connection to Vault with Kubernetes auth
#
#   3. ExternalSecret: grafana-credentials
#      - Defines which secrets to fetch from Vault
#      - Creates Kubernetes Secret with Grafana admin credentials
#
# Vault Path: secret/shared/grafana
# Vault Policy: monitoring-policy (read access only)
#
# See:
#   - https://external-secrets.io/latest/provider/hashicorp-vault/
#   - https://grafana.com/docs/grafana/latest/setup-grafana/configure-security/
# ==============================================================================

---
# ==============================================================================
# 1. ServiceAccount for Monitoring Secrets
# ==============================================================================
# This ServiceAccount is used by the External Secrets Operator's SecretStore
# to authenticate with Vault. The SA token is sent to Vault, which verifies it
# via the Kubernetes TokenReview API and returns a Vault token with the
# permissions defined in 'monitoring-policy'.
#
# Security Note:
#   - This SA only has permissions to read Grafana secrets (monitoring-policy)
#   - It cannot access secrets for other services (principle of least privilege)
#   - The SA is namespace-scoped (monitoring) for additional isolation
# ==============================================================================
apiVersion: v1
kind: ServiceAccount
metadata:
  name: monitoring-secrets-sa
  namespace: monitoring
  labels:
    app.kubernetes.io/name: monitoring-secrets
    app.kubernetes.io/component: external-secrets
    app.kubernetes.io/part-of: kube-prometheus-stack
  annotations:
    # Documentation annotation for audit and discoverability
    description: "ServiceAccount used by SecretStore to authenticate with Vault for Grafana secrets"

---
# ==============================================================================
# 2. SecretStore for Vault Integration
# ==============================================================================
# A SecretStore is a namespaced resource that defines HOW to connect to an
# external secrets provider (in our case, HashiCorp Vault).
#
# Configuration:
#   - Provider: HashiCorp Vault
#   - Server: Internal Kubernetes service address
#   - Auth: Kubernetes authentication method
#   - Role: monitoring-role (maps to monitoring-policy in Vault)
#
# Why SecretStore vs ClusterSecretStore?
#   - SecretStore is namespace-scoped (more secure, follows least privilege)
#   - ClusterSecretStore would allow any namespace to use it (less secure)
#   - We use SecretStore to isolate each namespace's secret access
# ==============================================================================
apiVersion: external-secrets.io/v1
kind: SecretStore
metadata:
  name: vault-backend
  namespace: monitoring
  labels:
    app.kubernetes.io/name: vault-backend
    app.kubernetes.io/component: external-secrets
    app.kubernetes.io/part-of: kube-prometheus-stack
spec:
  provider:
    vault:
      # -------------------------------------------------------------------------
      # Vault Server Configuration
      # -------------------------------------------------------------------------
      # Address of the Vault service within the Kubernetes cluster.
      # Using the full DNS name: <service>.<namespace>.svc.cluster.local
      server: "http://vault.vault.svc.cluster.local:8200"

      # Path to the KV secrets engine in Vault.
      # This is the mount point, not the full path to secrets.
      path: "secret"

      # KV engine version. We use v2 for:
      #   - Secret versioning (rollback capability)
      #   - Metadata support (creation time, version info)
      #   - Check-and-set operations (CAS)
      version: "v2"

      # -------------------------------------------------------------------------
      # Authentication Configuration
      # -------------------------------------------------------------------------
      auth:
        kubernetes:
          # Mount path of the Kubernetes Auth Method in Vault.
          # This is configured by setup-vault.sh and kubernetes-auth.sh.
          mountPath: "kubernetes"

          # The Vault role to assume when authenticating.
          # This role is defined in kubernetes-auth.sh and grants access to
          # the 'monitoring-policy' which allows reading secret/shared/grafana.
          role: "monitoring-role"

          # Reference to the ServiceAccount used for authentication.
          # ESO will use this SA's token to authenticate with Vault.
          # The SA must be in the same namespace as this SecretStore.
          serviceAccountRef:
            name: monitoring-secrets-sa

---
# ==============================================================================
# 3. ExternalSecret for Grafana Admin Credentials
# ==============================================================================
# An ExternalSecret defines WHAT secrets to fetch from the external provider
# and how to map them to a Kubernetes Secret.
#
# This ExternalSecret fetches Grafana admin credentials from Vault and creates
# a Kubernetes Secret that the kube-prometheus-stack Helm chart will use.
#
# Secrets Fetched:
#   - admin-user:     Grafana admin username (typically "admin")
#   - admin-password: Grafana admin password (randomly generated)
#   - secret-key:     Grafana secret key for signing cookies/tokens
#
# Target Secret: grafana-credentials
#   This name must match the 'admin.existingSecret' value in prometheus.yaml
# ==============================================================================
apiVersion: external-secrets.io/v1
kind: ExternalSecret
metadata:
  name: grafana-credentials
  namespace: monitoring
  labels:
    app.kubernetes.io/name: grafana-credentials
    app.kubernetes.io/component: external-secrets
    app.kubernetes.io/part-of: kube-prometheus-stack
spec:
  # Reference to the SecretStore that defines how to connect to Vault
  secretStoreRef:
    name: vault-backend
    kind: SecretStore

  # Refresh interval: how often ESO checks for secret updates in Vault
  # Default is 1h, but we use a shorter interval for faster secret rotation
  refreshInterval: "15m"

  # -------------------------------------------------------------------------
  # Target Kubernetes Secret Configuration
  # -------------------------------------------------------------------------
  target:
    # Name of the Kubernetes Secret to create
    # This must match 'grafana.admin.existingSecret' in Helm values
    name: grafana-credentials

    # CreationPolicy: Owner means ESO owns this secret and will delete it
    # when the ExternalSecret is deleted (garbage collection)
    creationPolicy: Owner

    # DeletionPolicy: Retain would keep the secret after ES deletion
    # We use the default (Delete) for clean resource management
    # deletionPolicy: Delete

  # -------------------------------------------------------------------------
  # Data Mapping: Vault -> Kubernetes Secret
  # -------------------------------------------------------------------------
  # Each entry maps a Vault secret field to a Kubernetes Secret key.
  # Format:
  #   - secretKey: Key name in the Kubernetes Secret
  #     remoteRef:
  #       key: Full path to the secret in Vault (KV v2: secret/data/...)
  #       property: Specific field within the secret
  # -------------------------------------------------------------------------
  data:
    # -------------------------------------------------------------------------
    # 1. Grafana Admin Username
    # -------------------------------------------------------------------------
    # Maps to: GF_SECURITY_ADMIN_USER environment variable
    # Expected value: "admin" (set in init-secrets.sh)
    # -------------------------------------------------------------------------
    - secretKey: admin-user
      remoteRef:
        key: secret/shared/grafana
        property: admin_user

    # -------------------------------------------------------------------------
    # 2. Grafana Admin Password
    # -------------------------------------------------------------------------
    # Maps to: GF_SECURITY_ADMIN_PASSWORD environment variable
    # This is a randomly generated password (32 alphanumeric chars)
    # Created by init-secrets.sh, stored securely in Vault
    #
    # IMPORTANT: To retrieve this password for first login:
    #   kubectl get secret grafana-credentials -n monitoring -o jsonpath='{.data.admin-password}' | base64 -d
    # -------------------------------------------------------------------------
    - secretKey: admin-password
      remoteRef:
        key: secret/shared/grafana
        property: admin_password

    # -------------------------------------------------------------------------
    # 3. Grafana Secret Key
    # -------------------------------------------------------------------------
    # Maps to: GF_SECURITY_SECRET_KEY environment variable
    # Used by Grafana to:
    #   - Sign session cookies
    #   - Encrypt sensitive data in the database
    #   - Sign API tokens
    #
    # WARNING: Changing this key will:
    #   - Invalidate all existing user sessions
    #   - Require re-authentication for all users
    # -------------------------------------------------------------------------
    - secretKey: secret-key
      remoteRef:
        key: secret/shared/grafana
        property: secret_key
