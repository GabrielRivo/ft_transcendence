import { Service } from 'my-fastify-decorators';
import { Resilient } from './decorators/resilient.decorator.js';
import { ValidateResult } from './decorators/validate.decorator.js';

// =============================================================================
// SCHEMA DEFINITIONS
// =============================================================================

/**
 * TypeScript type for successful game creation.
 * Returned by the Game Service when the game is successfully created (HTTP 201).
 */
export interface CreateGameSuccessDto {
	success: true;
	gameId: string;
	message: string;
}

/**
 * TypeScript type for failed game creation.
 * Returned by the Game Service when creation fails (HTTP 409).
 *
 * Error codes:
 * - GAME_ALREADY_EXISTS: A game with this ID already exists
 * - PLAYER_ALREADY_IN_GAME: One of the players is already in an active game
 * - INVALID_PLAYERS: Invalid player IDs provided
 */
export interface CreateGameErrorDto {
	success: false;
	error: 'GAME_ALREADY_EXISTS' | 'PLAYER_ALREADY_IN_GAME' | 'INVALID_PLAYERS';
	message: string;
}

/**
 * TypeScript union type for all possible responses.
 * Use discriminated union pattern to narrow the type.
 */
export type CreateGameResponseDto = CreateGameSuccessDto | CreateGameErrorDto;

/**
 * JSON Schema for successful game creation response.
 */
const CreateGameSuccessSchema = {
	type: 'object',
	properties: {
		success: { type: 'boolean', const: true },
		gameId: { type: 'string', minLength: 1 },
		message: { type: 'string' },
	},
	required: ['success', 'gameId', 'message'],
	additionalProperties: true,
};

/**
 * JSON Schema for failed game creation response.
 */
const CreateGameErrorSchema = {
	type: 'object',
	properties: {
		success: { type: 'boolean', const: false },
		error: {
			type: 'string',
			enum: ['GAME_ALREADY_EXISTS', 'PLAYER_ALREADY_IN_GAME', 'INVALID_PLAYERS'],
		},
		message: { type: 'string' },
	},
	required: ['success', 'error', 'message'],
	additionalProperties: true,
};

/**
 * Combined JSON Schema for all possible Game Service responses.
 * Uses JSON Schema's oneOf for discriminated union based on the `success` field.
 */
const CreateGameResponseSchema = {
	oneOf: [CreateGameSuccessSchema, CreateGameErrorSchema],
};

/**
 * Input DTO for creating a new game.
 * This defines the payload structure sent to the Game Service.
 */
export interface CreateGameInput {
	/**
	 * Unique identifier for the game session.
	 * Generated by the Matchmaking Service.
	 * Format can be UUID or custom (e.g., "match-{uuid}", "game-{timestamp}").
	 */
	gameId: string;

	/**
	 * User ID of the first player.
	 * Comes from the Matchmaking Service after match confirmation.
	 * String representation of the numeric Auth Service user ID.
	 */
	player1Id: string;

	/**
	 * User ID of the second player.
	 * Comes from the Matchmaking Service after match confirmation.
	 * String representation of the numeric Auth Service user ID.
	 */
	player2Id: string;

	/**
	 * Type of the game (e.g., 'ranked', 'friend').
	 */
	type: 'local' | 'tournament' | 'ranked' | 'friend';

	tournamentId?: string;

	isFinal?: boolean;
}

@Service()
export class GameService {
	/**
	 * Base URL for the Game Service.
	 * Configured via GAME_SERVICE_URL environment variable.
	 *
	 * @remarks
	 * In Docker/Kubernetes, this typically points to the service name (e.g., http://game:3000).
	 * In local development, it defaults to localhost with a different port.
	 */
	private readonly gameServiceUrl = process.env.GAME_SERVICE_URL;

	/**
	 * Creates a new game session in the Game Service.
	 *
	 * This is the public entry point for creating games. It delegates to the
	 * protected `createGameRequest` method which handles the actual HTTP call
	 * with resilience patterns.
	 *
	 * @param input - Game creation parameters
	 * @param input.gameId - Unique identifier for the game
	 * @param input.player1Id - First player's user ID
	 * @param input.player2Id - Second player's user ID
	 *
	 * @returns Promise resolving to the creation result (success or error)
	 *
	 * @throws Never throws - Errors are caught by @Resilient and return a fallback
	 */
	public async createGame(input: CreateGameInput): Promise<CreateGameResponseDto> {
		return this.createGameRequest(input);
	}

	/**
	 * Internal method performing the actual HTTP POST request to the Game Service.
	 *
	 * ## Decorator Execution Order (Top to Bottom = Outer to Inner)
	 *
	 * 1. **@Resilient** (Outer): Wraps everything in try/catch with timeout
	 *    - Catches network errors (ECONNREFUSED, timeouts, etc.)
	 *    - Catches validation errors thrown by @ValidateResult
	 *    - Returns fallback value on any error
	 *
	 * 2. **@ValidateResult** (Inner): Validates the response against schema
	 *    - Runs AFTER the HTTP call succeeds
	 *    - Throws if response doesn't match CreateGameResponseSchema
	 *    - The thrown error is caught by @Resilient
	 *
	 * @param input - Game creation parameters
	 * @returns Promise resolving to validated response (success or error)
	 *
	 * @remarks
	 * The fallback returns `success: false` with error code 'GAME_ALREADY_EXISTS'
	 * to indicate the game wasn't created due to a service communication issue.
	 * The caller (MatchmakingService) should handle this gracefully, possibly
	 * by retrying or notifying players of the failure.
	 *
	 * The timeout is set to 3 seconds as game creation should be fast.
	 * If the Game Service is slow/down, we prefer failing fast with a fallback.
	 */
	@Resilient<CreateGameResponseDto>({
		context: 'GameService',
		timeoutMs: 3000,
		// Static fallback value - matches CreateGameErrorDto structure
		// The caller should check `success: false` and handle the failure appropriately
		fallback: {
			success: false as const,
			error: 'GAME_ALREADY_EXISTS' as const,
			message: 'Failed to reach Game Service - fallback response',
		},
		logAsError: true, // Game creation failures are critical
	})
	@ValidateResult(CreateGameResponseSchema)
	protected async createGameRequest(input: CreateGameInput): Promise<CreateGameResponseDto> {
		// Endpoint: POST /games (as defined in GameController)
		const targetUrl = `${this.gameServiceUrl}/games`;
		const response = await fetch(targetUrl, {
			method: 'POST',
			headers: {
				'Content-Type': 'application/json',
				// Note: For internal service-to-service calls, we might want to add
				// an internal API key or service token here in production.
				// 'X-Internal-Service': 'matchmaking'
			},
			body: JSON.stringify({
				gameId: input.gameId,
				player1Id: input.player1Id,
				player2Id: input.player2Id,
				type: input.type,
				tournamentId: input.tournamentId,
				isFinal: input.isFinal,
			}),
		});

		if (response.status === 201 || response.status === 409) {
			const data = (await response.json()) as CreateGameResponseDto;
			return data;
		}

		const errorBody = await response.text().catch(() => 'Unable to read response body');
		const errorMessage = `HTTP Error ${response.status}: ${response.statusText} | Body: ${errorBody}`;
		throw new Error(errorMessage);
	}

	/**
	 * Health check method to verify Game Service connectivity.
	 *
	 * Useful for debugging and monitoring service mesh health.
	 *
	 * @returns Promise resolving to true if Game Service is reachable
	 */
	public async isHealthy(): Promise<boolean> {
		try {
			const response = await fetch(`${this.gameServiceUrl}/health`, {
				method: 'GET',
				signal: AbortSignal.timeout(2000), // 2 second timeout for health checks
			});
			return response.ok;
		} catch (error) {
			return false;
		}
	}
}
